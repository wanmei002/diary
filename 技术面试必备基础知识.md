### 数据库
#### 事务的 ACID 
    > 事务的开启可以用 `begin` `start transaction`;
 - A(Atomicity) 原子性
    + 不可分割的最小单元，要么全部成功，要么全部失败，失败回滚
 - C(Consistency) 一致性
    + 事务在执行的过程中对一个数据的读取结果都是一致的
 - I(Isolation) 隔离性
    + 一个事务所做的修改在最终提交前, 对其它事务是不可见的
 - D(Durability) 持久性
    + 一个事务一旦提交, 则其所做的修改将会永远保存到数据库中, 即使系统发生崩溃，事务执行的结果也不能丢失
        > 使用重做日志来保证持久性
     
#### 不同的隔离级别出现的问题    
 - 脏读 读取到了另一事务没有提交的数据
 - 不可重复读  读取了另一个事务已经提交的数据
 - 幻读 读取到了另一个事务增加的数据(insert)
 
#### 锁
##### MySQL提供了两种锁的粒度: 行级锁(InnoDB支持) 和 表锁(一般数据库都支持)
 - 锁的数据量越小，发生锁的争用越小，系统的并发程度就越高
 - 加锁需要消耗资源，锁的各种操作(包括获取锁、释放锁、检查锁状态等)都会增加系统开销。因此封锁粒度越小 系统开销越大
##### 锁类型
 - 排它锁 又称写锁  select ... for update
    + 一个事务对数据A加了写锁，这个事务可以对A进行读写操作, 加锁期间其它事务不能对A加任何锁
 - 共享锁 又称读锁  select ... lock in share mode
    + 一个事务对数据A加了读锁, 这个事务可以对A进行读取操作, 但是不能进行更新操作, 加锁期间其它食物能对A加读锁，但是不能加写锁
    
    
