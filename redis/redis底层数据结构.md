#### 1 简单动态字符串
 - redis 是用C语言写的，但是对于 redis 的字符串，却不是 C 语言中的字符串(即以空字符串 ' \0'结尾的字符数组),
 它是自己构建了一种名为 简单动态字符串(simple dynamic string . SDS) 的抽象类型,并将 SDS 作为 redis 的默认字符串表示
 ```CGO
    struct sdshdr{
        // 记录buf 数组中已使用字节的数量
        // 等于 sds 保存字符串的长度
        int len;
        // 记录 buf 中未使用字节的数量
        int free;
        // 字节数组 用于保存字符串
        char buf[];
    }
 ```
 - 上面的定于相对与 C 中字符串的定于多了 len free等属性。相对于 C 语言的字符串有什么好处呢？
    + 由于 len 属性的存在，获取字符串的长度复杂度O(1), 而 C 获取字符串的长度是通过遍历来实现的，复杂度为O(n)。 通过 strlen key 命令可以获取 key 的字符串长度
    + `杜绝缓冲区溢出` : C语言中使用 strcat 函数来进行两个字符串的拼接，一旦没有分配足够长度的内存空间，就会造成缓存区溢出。而对于 sds 而言，字符串拼接前会先判断 len+free 是否满足需求
    如果不满足，会进行相应的空间扩展，然后在进行修改操作，所以不会出现缓冲区溢出
    + `减少修改字符串的内存重新分配次数` : C语言由于不记录字符串的长度，所以如果要修改字符串，必须要重新分配内存(先释放再申请), 因为如果没有重新分配，过长会造成缓冲区溢出，字符串过小会造成内存泄露。
    而对于 sds , 由于 len free 属性的存在，对于修改字符串 sds 实现了空间预分配和惰性空间释放两种策略:
        + `空间预分配` : 对于字符串扩展的时候，申请的内存比实际需求的多，这样可以减少连续执行字符串增长操作所需的内存重分配次数
        + `惰性空间释放` : 对字符串减少操作的时候不会立即使用内存重新分配来回收缩短后多余的字节，而是使用 free 属性将这些字节的数量记录下来，等待后续使用
    + `二进制安全` : 因为 C 字符串已空字符作为字符串结束的标识，而对于一些二进制文件(如图片等), 内容可能包含空字符串，因此C字符串无法正确存取，而所有 sds 的 api 都是以处理二进制的方式来处理 buf 里面的元素，
    并且 sds 不是以空字符串来判断是否结束的，是按 len 的长度来判断是否结束的
    + `兼容部分 C 字符串函数`
    
    
#### 2 链表
 - 链表节点
    ```cgo
    typedef struct listNode{
       struct listNode *prev;// 前节点
       struct listNode *next;// 后节点
       void *value;// 节点值
    }
    ```
    
 - 整个链表的数据结构
    ```cgo
    typedef struct list {
       listNode *head;// 表头节点
       listNode *tail;// 表尾节点
       unsigned long len;// 链表所包含的节点数量
       void (*free) (void *ptr);// 节点值复制函数
       void (*free) (void *ptr);// 节点值释放函数
       int (*match) (void *ptr, void *key);// 节点值对比函数
    }
    ```
    
 - redis 链表特性:
    + 双端: 链表具有前置节点和后置节点的引用
    + 无环: 表头节点的 prev 指针和表尾节点的 next 指针都指向 NULL, 对链表的访问都是 NULL 结束
    + 带链表长度计数器: 通过 len 属性获取链表长度的时间复杂度为O(1)
    + 多态: 链表节点使用 void* 指针来保存节点值，可以保存各种不同类型的值
    
##### 3 字典
 - C语言里面没有内置 map 这种数据结构，所以 字典依然是 redis 自己实现构建的，redis 的字典使用 哈希表 作为底层实现
 - 哈希表结构定义
    ```cgo
       typedef struct dictht{
           dictEntry **table;// 哈希表数组
           unsigned long size;// 哈希表大小
           unsigned long sizemask;// 哈希表大小掩码, 用于计算索引值，总是等于 size-1
           unsigned long used;// 该哈希表已有节点的数量
       }
    ```
 - 哈希表是由数组 table 组成的, table 中每个元素都是指向 dict.h/dictEntry 结构, dictEntry 结构定义如下:
    ```cgo
       typedef struct dictEntry{
           void *key;//键
           // 值
           union {
               void *val;
               uint64_tu64;
               int64_ts64;
           };
           struct dictEntry *next;//指向下一个哈希值节点，形成链表，如果 有的key 重复了 就往这个后面追加节点
       }
    ```
    
 - key 用来保存键, val 属性用来保存值, 值可以是一个指针, 也可以是 uint64_t 整数, 也可以是 int64_t 整数
    > `注意`: 这里还有一个指向下一个哈希表节点的指针, 我们知道哈希表最大的问题是存在哈希冲突, 如何解决哈希冲突, 有开放地址法和链表地址法。
 这里采用的便是链地址法, 通过 next 这个指针可以将多个哈希值相同的键值对连接在一起，用来解决哈希冲突
 
 - 扩容和收缩
    + 当哈希表保存的键值对太多或者太少时, 就要通过 rehash(重新散列) 来对哈希表进行相应的扩展或者收缩，具体步骤:
        - 如果执行扩展操作，会基于原先的哈希表创建一个大小等于原哈希表所占空间的2倍，然后把原先的哈希表移动到新的哈希表中，释放原先的哈希表。相反如果执行的是收缩操作, 每次收缩是根据已使用空间缩小一倍常见一个新的哈希表
            + 重新利用哈希算法计算索引值，然后将键值对放到新的哈希表位置上
            + 所有键值对都迁移完毕后, 释放原哈希表的内存空间
            + 扩容条件  负载因子=哈希表已保存节点数量 / 哈希表大小
                - 负载因子大于等于1 // 没有执行 AOF 操作
                - 负载因子大于等于5 // 执行 AOF 操作
                
 - 渐进式 rehash
    + 什么叫渐进式 rehash? 也就是说扩容和收缩操作不是一次性、集中式完成的, 而是分多次、渐进式完成的。如果保存在 redis 中键值对只有几个几十个, 那么 rehash 操作可以瞬间完成。可是有几百万个，甚至更多直接进行 rehash 可能
    会导致不能进行其它操作，所以 redis 采用渐进式rehash操作，字典在删除查找等操作可能会在两个哈希表上进行，第一个哈希表没有找到, 就会去第二个哈希表上进行查找，但是增加一定是在新哈希表上
    
    
    
#### 4 跳跃表
 - 跳跃表是一种有序数据结构, 它通过在每个节点中维持多个指向其它节点的指针从而达到快速访问节点的目的。具有如下性质:
    + 由很多层结构组成
    + 链表中的每个节点都包含两个指针, 一个指向同一层的下一个链表节点, 另一个指向下一层的同一个链表节点
    ```cgo
    // redis 中跳跃表节点定义如下
    typedef struct zskiplistNode{
       // 层
       struct zskiplistLevel{
           // 前进指针
           struct zskiplistNode *forward;
           // 跨度
           unsigned int span;
       }
    
       // 后退指针
       struct zskiplistNode *backward;
       // 分值
       double score;
       robj *obj;
    }
    

    // 多个跳跃表节点构成一个跳跃表
    typedef struct zskiplist{
       // 表头节点和表尾节点
       struct zskiplistNode *header, *tail;
       // 表中节点的数量
       unsigned long length;
       // 表中层数最大的节点的层数
       int level;
    }

    ```
    
    
#### 5 整数集合
 - 整数集合(intset) 是 redis 用于保存整数值的集合抽象数据类型, 它可以保存类型为 int16_t、int32_t或者int64_t的整数值,并且保证集合中不会出现重复元素
    ```cgo
    typedef struct intset {
       uint32_t encoding;
       uint32_t length;
       int8_t contents[];
    }
    ```
    
 - 整数集合的每个元素都是 contents 数组的一个数据项, 它们按照从小到大的顺序排列, 并且不包含任何重复项
 - length 属性记录了 contents 数组的大小
 - 需要注意的是 虽然 contents 数组申明为 int8_t 类型, 但是实际上 contents 数组并不保存任何 int8_t 类型的值，其真正类型有 encoding 来决定
 
 - `升级`: 当新增元素类型比原集合元素类型的长度要大时, 需要对整数集合进行升级, 才能将新元素放入整数集合中具体步骤如下:
    + 根据新元素类型, 扩展整数集合底层数组的大小, 并为新元素分配空间
    + 将底层数组现有的所有元素都转成与新元素相同类型的元素, 并将转换后的元素放到正确的位置, 放置过程中维持整个元素顺序都是有序的
    + 将新元素添加到整数集合中(保证有序)
    
 - 不支持`降级`操作
 
#### 6 压缩列表
 - 压缩列表(ziplist) 是 redis 为了节省内存而开发的，是由一系列特殊编码的连续内存块组成的顺序型数据结构, 一个压缩列表可以包含任意多个节点(entry), 每个节点可以保存一个字节数组或者一个整数值
 - `压缩列表的原理` : 压缩列表并不是对数据利用某种算法进行压缩，而是将数据按照一定规则编码在一块连续的内存区域，目的是节省内存
 - `压缩列表组成部分` : `zlbytes` : `zltail` : `zllen` : `entry1` : `entry2` : ··· : `entryN` : `zlend`
 - `压缩列表各个组成部分的详细说明`
    
    |属性     | 类型     |长度 | 用途|
    | ----- | --------- | ----- | ------- |
    |zlbytes | uint32_t|4字节| 记录整个压缩列表占用的内存字节数; 在对压缩列表进行内存重分配，或者计算zlend 位置时使用|
    |zltail  | uint32_t|4字节| 记录压缩列表表尾节点距离压缩列表的起始地址有多少字节; 通过这个偏移量程序无需遍历整个压缩列表就可以确定表尾节点的地址|
    |zllen   | uint16_t|2字节| 记录压缩列表包含的节点数量, 如果 值小于 UNIT16_MAX 时, 这个属性的值是节点的数量, 如果等于 UNIT16_MAX 则需要遍历列表来获取数量|
    |entryX  | 列表节点  |不定 | 压缩列表包含的各个节点, 节点的长度由节点保存的内容决定|
    |zlend   | uint8_t |1字节| 特殊值 0xFF(十进制255), 用于标记压缩列表的末端|
 
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
    