## MVCC 是建立在 读已提交 和 可重复读 级别上面的
MVCC的实现原理主要依赖于记录中的三个隐藏字段: undo log, read view 来实现的
#### 隐藏字段
每行记录除了我们自定义的字段外, 还有数据库隐式定义的 DB_TRX_ID, DB_ROLL_PTR, DB_ROW_ID
##### DB_TRX_ID
6字节, 最近修改事务id, 记录创建这条记录或者最后一次修改记录的事务id
##### DB_ROLL_PTR
7字节, 回滚指针, 指向这条记录的上一个版本, 用于配合undo log, 指向上一个旧版本
##### DB_ROW_ID
6字节, 隐藏的主键, 如果数据表没有主键, 那么 innodb 会自动生成一个 6 字节的 row_id

##### 版本比对规则
当执行查询 sql 时会生成一致性视图 read-view, 它由执行查询时所有未提交事务id数组(数组里的最小的id为 min_id)
和已创建的最大事务id(max_id) 组成, 然后从 undo log 日志最新的记录的事务id 照着特定的规则一一比对，如果比对上了则生成快照

版本比对规则:
1. 如果落在绿色部分(trx_id<min_id), 表示这个版本是已提交的事务生成的, 这个数据是可见的;
2. 如果落在红色部分(trx_id>max_id), 表示这个版本是由将来启动的事务生成的, 是肯定不可见的;
3. 如果落在黄色部分(min_id =< trx_id <= max_id) 那就有两种情况
    1. 若 row 的 trx_id 在数组中, 表示这个版本是由还没提交的事务生成的, 不可见, 当前自己的事务是可见的;
    2. 若 row 的 trx_id 不在数组中, 表示这个版本是已经提交了的事务生成的, 可见



## 事务隔离级别
读未提交: 脏读, 不可重复读，幻读
读已提交: 不可重复读, 幻读
可重复读: 幻读
串行化: 


## 答疑
 1. 单纯的查询, mysql 不会加锁, 会用 mvcc 的机制读取数据
 2. 如果用 select .... in share mode 这种方式是加的 s 共享锁
 3. 如果用 select .... for update 这种方式是加的 x 排它锁
 4. 如果是 update 或 delete 都会加 X 排它锁, 具体这个锁是加在聚簇索引还是二级索引上对应哪条记录,
 要看过滤条件是哪种索引(主键、唯一、非唯一) 和 事务隔离级别来确定
 5. innodb 的行锁包括: 记录锁、间隙锁(解决幻读问题)、组合锁