#### golang 中的 nil
 - 官方文档: 下列 `6` 大类型家族的零值为 `nil`, 其它类型值都不可能为 `nil`
 	+ pointer 指针类型
 	+ slice 切片类型
 	+ map 字典类型
 	+ channel 数据通道类型
 	+ function 函数类型
 	+ interface 接口类型

 - nil 为未确定类型值, 它有很多可能类型, 但是它没有默认类型
 	+ v := nil // 编译错误
 	```go
 	p := (*struct{})(nil)
	s := []int(nil)
	m := map[int]bool(nil)
	c := chan string(nil)
	f := (func())(nil)
	i := interface{}(nil)
 	```

 - nil 是占内存的， php js 中 null 是不占内存的
 - nil != nil, nil 指向的数据类型是不同的


#### 类型 T 和 \*T的方法集
 - 定义在结构体 `T`上的方法属于类型 `\*T` 的方法集中的一员，反之却不然，
 即定义在类型 `\*T` 上的方法并不属于类型 `T` 的方法集中的一员
 - 为什么定义在类型T上的方法属于类型 `\*T` 的方法集中的一员, 但定义在 类型 `\*T` 
 上的方法却不属于类型 T 的方法集合的一员
 	+ 对于一个指针值 `p` 在编译阶段对它的解引用 `\*p` 总是合法的
 	+ 但是对于很多非指针值 `v` , 在编译阶段, 取它的地址 `&v` 却并不总是合法的(`_ = &"abc"`), 难以将 `v` 自动转换为 `&v`
 - 直接值不能取地址? 为什么有很多 &T{} 这种用法？
 	```go
		pm := &map[string]string{}
		ps := &[]string{}
		pst := &struct{}{}
		pmt := &MyType{}
 	``` 
 	+ &T{} 是为了编程方便, 添加的一个 sugar, 是下面形式的缩写, 而不是临时值不能取地址的一个例外
 	```go
	temp := T{}
	&temp
 	```
 	+ 编译器只会自动对变量取地址, 而不会自动对直接值取地址