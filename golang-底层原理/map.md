### 总纲
hmap 中 的 buckets 是一个数组, 数组里的值是 bmap, 申请bmap地址的时候是申请的连续地址, 不仅申请了 bmap的,还有8个保存key 8个保存val, 还有一个 overflow 的地址;

### 插入|更新
如果有数据过来插入了, 先把 key hash计算，取起 `B` 计算在 buckets 中的索引, 找到然后挨个读取 bmap 中的 tophash 值跟 hash 值的高 8 位比较, 如果比较成功, 在比较后面连续内存的 key val值是否一样，
如果不一样，继续读取 overflow 中的是否有相同的值; 

如果有则更新，如果没有则在前面依次对比中，找到第一个空白的, 把数据插入进去。如果前面都是满的，则会在最后插入，如果最后一个也是满的，则创建一个新的 overflow 插入进去

查询跟删除一样

### hmap
 
 buckets 创建的数量是根据 B来创建的，
 
  1. 当 B<4时, 根据B创建桶的个数的规则为: 2^B(标准桶)
  2. 当 B>=4时, 根据B创建桶的个数的规则为L 2^B + 2^(B-4) (标准桶+溢出桶)
  
hmap中的buckets 是一个数组，数组保存的元素是 bmap。
如果写入一个数据会先计算出hash值, 根据hash低 `B` 位计算出buckets的索引，然后根据 hash的高 8 位存入bmap.tophash中，存入到第几个位置，会去 bmap对应的位置的 key val 数组中插入数据(源码中 bmap没有 key val 属性)；

取出跟写入差不多
### bmap
type bmap struct {
    tophash \[8\]uint8
}

创建 bmap 的时候会在后面连续申请
 


### 扩容
#### 翻倍扩容
##### 引发的条件
\(map中数据总个数/桶格式\)>6.5  引发翻倍扩容
##### 扩容流程
hmap中的 B+1，创建一个双倍桶数量的数组，开始慢慢扩容，
把老桶中的数据根据key的 hash 值的低 `B` 位,
重新分配在新桶列表中的索引, 根据高8位计算出所在桶中的索引。

 - 使用了太多的溢出桶\( 溢出桶使用的太多会导致map处理速度降低 \)
    + B<=15 时使用的溢出桶个数 >= 2^B 时, 引发等量扩容
    + B>15  时使用的溢出桶格式 >= 2^15时, 引发等量扩容
    

