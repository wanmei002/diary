## 三色标记法
### Mark-And-Sweep(标记清扫)
 在三色标记法之前有一个算法叫 `Mark-And-Sweep(标记清扫)`, 这个算法就是严格按照追踪式算法的思路来实现的。
 这个算法会记录一个标志位来记录对象是否被使用。最开始所有的标记位都是0，如果发现对象是可达的就会置为1.
 
 标记完成后，会将未被标记的对象统一清理, 再次把所有的标记位设置成0，方便下次清理。
 
 这个算法有个严重的问题: gc 执行期间需要把整个程序完全暂停，不能异步进行 gc 操作。如果异步操作，新的进程在运行gc，而标记进程已经把追踪到的对象标记为0， 这样很可能会把追踪到的变量清除
 对于实时性要求高的系统来说, 这种需要长时间挂起的标记清扫法是不可接受的。所以就需要一个算法来解决 gc 运行时程序长时间挂起的问题, 那就是三色标记法
### Mark-And-Sweep 算法的改进: 三色标记法
#### 三色标记法的简单原理
 1. 在进入 gc 的三色标记阶段的一开始, 所有对象都是白色的
 2. 遍历 栈上的对象或者堆上的全局变量, 把根对象引用的对象标记为灰色, 从白色集合放入灰色集合
 3. 遍历灰色集合, 将灰色对象引用的对象从白色集合放入灰色集合, 之后将此灰色对象放入黑色集合
 4. 重复第三步, 直到灰色集合中无任何对象
 5. 回收白色集合里的所有对象, 本次垃圾回收结束
 
#### 中间产生误回收的问题
 在 gc 运行过程中程序的函数栈内可能会有新分配的对象, 那么这些对象该怎么通知到 gc, 怎么给它们着色呢? 
 
 如果还是按照之前新建的对象标记为白色就有可能出现被误回收的可能
#### 屏障技术 解决新内存误回收
屏障技术是在用户程序读取对象、创建新对象以及更新对象指针时执行的一段代码；

根据操作类型不同, 我们可以将它们分成读屏障和写屏障两种；

因为读屏障需要在读操作中加入代码片段, 对用户程序的性能影响很大, 所以编程语言往往都会采用写屏障保证三色不变性

#### golang 的混合写屏障
 但是运行时并没有在所有的垃圾收集根对象上开启插入写屏障。
 
 因为 Go 语言的应用程序可能包含成百上千的 goroutine，
 
 而垃圾收集的根对象一般包括全局变量和栈对象，如果运行时需要在几百个 goroutine 的栈上都开启写屏障，
 
 会带来巨大的额外开销，所以 Go 团队在实现上选择了在`标记阶段`完成时`暂停程序、将所有栈对象标记为灰色并重新扫描`
 
#### golang 一次完整的 gc 过程
##### 标记准备
暂停程序，开启写屏障，根对象入队
##### 标记阶段
恢复程序执行，并发标记内存中的对象，写屏障会将被覆盖的指针和新指针都标记成灰色，而所有新创建的对象都会被直接标记成黑色

标记完, 开始扫描所有对象(goroutine的栈 全局变量)

依次处理灰色队列中的对象，将对象标记成黑色并将它们指向的对象标记成灰色

##### 标记终止阶段
暂停程序，清理处理器上的线程缓存。初始化清理状态并关闭写屏障

##### 清理阶段
后台并发清理所有的内存管理单元